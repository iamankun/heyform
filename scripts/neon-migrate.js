// Generated by An Kun

const { neon } = require('@neondatabase/serverless')
const fs = require('fs')
const path = require('path')

async function runNeonMigrations() {
  console.log('üöÄ Starting Neon migrations...')
  
  const database_url = process.env.DATABASE_URL_UNPOOLED || process.env.DATABASE_URL
  
  if (!database_url) {
    throw new Error('DATABASE_URL or DATABASE_URL_UNPOOLED is required')
  }

  const sql = neon(database_url)
  
  try {
    // Create migrations table
    await sql`
      CREATE TABLE IF NOT EXISTS migrations (
        id SERIAL PRIMARY KEY,
        migration_name VARCHAR(255) NOT NULL,
        executed_at TIMESTAMP DEFAULT NOW()
      )
    `

    // Get executed migrations
    const executed_migrations = await sql`
      SELECT migration_name FROM migrations ORDER BY id
    `
    
    const executed = executed_migrations.map(row => row.migration_name)

    // Read migration files
    const migrations_dir = path.join(__dirname, '../packages/server/src/migrations')
    const migration_files = fs.readdirSync(migrations_dir)
      .filter(file => file.endsWith('.sql'))
      .sort()

    for (const file of migration_files) {
      if (!executed.includes(file)) {
        console.log(`‚ö° Running migration: ${file}`)
        
        const migration_sql = fs.readFileSync(
          path.join(migrations_dir, file), 
          'utf8'
        )
        
        await sql.transaction(async (tx) => {
          await tx.unsafe(migration_sql)
          await tx`INSERT INTO migrations (migration_name) VALUES (${file})`
        })
        
        console.log(`‚úÖ Migration ${file} completed`)
      }
    }

    console.log('üéâ All Neon migrations completed successfully!')
  } catch (error) {
    console.error('‚ùå Migration failed:', error)
    process.exit(1)
  }
}

runNeonMigrations()
