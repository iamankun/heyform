// Generated by An Kun
"use server";
import { neon } from "@neondatabase/serverless";
import { validateStackToken, getStackUser } from '../lib/stack-auth';

// Ensure DATABASE_URL is available and secure
if (!process.env.DATABASE_URL) {
  throw new Error('DATABASE_URL environment variable is required');
}

const sql = neon(process.env.DATABASE_URL);
const sql_unpooled = neon(process.env.DATABASE_URL_UNPOOLED || process.env.DATABASE_URL!);

export async function getData() {
  try {
    const data = await sql`
      SELECT 
        current_database() as database_name,
        current_user as user_name,
        version() as postgres_version
    `;
    return data;
  } catch (error) {
    console.error('Database query failed:', error);
    throw new Error('Failed to fetch data from database');
  }
}

export async function getUserData(user_id: string) {
  try {
    const data = await sql`
      SELECT 
        id,
        email,
        first_name,
        last_name,
        avatar_url,
        is_email_verified,
        created_at,
        updated_at
      FROM users 
      WHERE id = ${user_id} AND deleted_at IS NULL
    `;
    return data;
  } catch (error) {
    console.error('Failed to get user data:', error);
    throw new Error('User not found');
  }
}

export async function getWorkspacesByUser(user_id: string) {
  try {
    const data = await sql`
      SELECT 
        w.id,
        w.name,
        w.slug,
        w.logo_url,
        w.settings,
        w.created_at,
        wm.role
      FROM workspaces w
      JOIN workspace_members wm ON w.id = wm.workspace_id
      WHERE wm.user_id = ${user_id} AND w.deleted_at IS NULL
      ORDER BY w.created_at DESC
    `;
    return data;
  } catch (error) {
    console.error('Failed to get workspaces:', error);
    return [];
  }
}

export async function createForm(form_data: {
  title: string;
  description?: string;
  project_id: string;
  created_by: string;
  form_schema?: any;
  settings?: any;
}) {
  try {
    const data = await sql`
      INSERT INTO forms (
        title, 
        description, 
        project_id, 
        form_schema, 
        settings, 
        created_by
      )
      VALUES (
        ${form_data.title}, 
        ${form_data.description}, 
        ${form_data.project_id}, 
        ${JSON.stringify(form_data.form_schema)}, 
        ${JSON.stringify(form_data.settings)}, 
        ${form_data.created_by}
      )
      RETURNING id, title, description, status, created_at
    `;
    return data[0];
  } catch (error) {
    console.error('Failed to create form:', error);
    throw new Error('Failed to create form');
  }
}

export async function submitFormData(submission_data: {
  form_id: string;
  submission_data: any;
  user_agent?: string;
  ip_address?: string;
}) {
  try {
    const data = await sql`
      INSERT INTO submissions (
        form_id, 
        submission_data, 
        user_agent, 
        ip_address
      )
      VALUES (
        ${submission_data.form_id}, 
        ${JSON.stringify(submission_data.submission_data)}, 
        ${submission_data.user_agent}, 
        ${submission_data.ip_address}
      )
      RETURNING id, created_at
    `;
    return data[0];
  } catch (error) {
    console.error('Failed to submit form data:', error);
    throw new Error('Failed to submit form');
  }
}

export async function createWorkspace(name: string, slug: string, owner_id: string, logo_url?: string) {
  const workspace_data = await sql`
    INSERT INTO workspaces (name, slug, owner_id, logo_url)
    VALUES (${name}, ${slug}, ${owner_id}, ${logo_url})
    RETURNING id, name, slug, logo_url, created_at
  `;
  
  // Add owner as workspace member
  await sql`
    INSERT INTO workspace_members (workspace_id, user_id, role, joined_at)
    VALUES (${workspace_data[0].id}, ${owner_id}, 'owner', NOW())
  `;
  
  return workspace_data[0];
}

export async function createProject(name: string, workspace_id: string, created_by: string) {
  const data = await sql`
    INSERT INTO projects (name, workspace_id, created_by)
    VALUES (${name}, ${workspace_id}, ${created_by})
    RETURNING id, name, workspace_id, created_at
  `;
  return data[0];
}

export async function createForm(
  title: string, 
  project_id: string, 
  created_by: string, 
  description?: string,
  form_schema?: any,
  settings?: any
) {
  const data = await sql`
    INSERT INTO forms (title, description, project_id, form_schema, settings, created_by)
    VALUES (${title}, ${description}, ${project_id}, ${JSON.stringify(form_schema)}, ${JSON.stringify(settings)}, ${created_by})
    RETURNING id, title, description, status, created_at
  `;
  return data[0];
}

export async function submitFormData(form_id: string, submission_data: any, user_agent?: string, ip_address?: string) {
  const data = await sql`
    INSERT INTO submissions (form_id, submission_data, user_agent, ip_address)
    VALUES (${form_id}, ${JSON.stringify(submission_data)}, ${user_agent}, ${ip_address})
    RETURNING id, created_at
  `;
  return data[0];
}

export async function updateFormStatus(form_id: string, status: string) {
  const data = await sql`
    UPDATE forms 
    SET status = ${status}, updated_at = NOW()
    WHERE id = ${form_id} AND deleted_at IS NULL
    RETURNING id, title, status, updated_at
  `;
  return data[0];
}

export async function deleteForm(form_id: string) {
  const data = await sql`
    UPDATE forms 
    SET deleted_at = NOW()
    WHERE id = ${form_id}
    RETURNING id
  `;
  return data[0];
}

// Use unpooled connection for heavy analytics queries
export async function getFormAnalytics(form_id: string) {
  const data = await sql_unpooled`
    SELECT 
      COUNT(*) as total_submissions,
      COUNT(DISTINCT ip_address) as unique_visitors,
      DATE(created_at) as submission_date,
      COUNT(*) as daily_count
    FROM submissions
    WHERE form_id = ${form_id}
    GROUP BY DATE(created_at)
    ORDER BY submission_date DESC
    LIMIT 30
  `;
  return data;
}

export async function testDatabaseConnection(): Promise<boolean> {
  try {
    const result = await sql`SELECT 1 as test, current_database() as db_name, current_user as user_name`;
    console.log('ðŸ”— Database connection test successful:', {
      database_name: result[0]?.db_name,
      user_name: result[0]?.user_name
    });
    return true;
  } catch (error) {
    console.error('âŒ Database connection test failed:', error);
    return false;
  }
}

export async function initializeDatabase() {
  try {
    // Test basic connection
    const connection_test = await testDatabaseConnection();
    if (!connection_test) {
      throw new Error('Database connection failed');
    }

    // Get database info
    const db_info = await sql`
      SELECT 
        current_database() as database_name,
        current_user as user_name,
        version() as postgres_version
    `;

    console.log('âœ… Database initialized successfully:', db_info[0]);
    return {
      success: true,
      database_info: db_info[0]
    };
  } catch (error) {
    console.error('âŒ Database initialization failed:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

export async function syncStackUserToDatabase(stack_token: string) {
  try {
    const validation_result = await validateStackToken(stack_token);
    
    if (!validation_result.success || !validation_result.user) {
      throw new Error('Invalid Stack Auth token');
    }

    const { user } = validation_result;
    
    // Check if user exists in our database
    const existing_user = await sql`
      SELECT id, email FROM users 
      WHERE email = ${user.email}
    `;

    if (existing_user.length > 0) {
      // Update existing user
      const updated_user = await sql`
        UPDATE users 
        SET 
          first_name = ${user.display_name?.split(' ')[0] || ''},
          last_name = ${user.display_name?.split(' ').slice(1).join(' ') || ''},
          avatar_url = ${user.profile_image_url},
          is_email_verified = ${user.is_email_verified},
          updated_at = NOW()
        WHERE email = ${user.email}
        RETURNING id, email, first_name, last_name, avatar_url
      `;
      
      return {
        success: true,
        user: updated_user[0],
        action: 'updated'
      };
    } else {
      // Create new user
      const new_user = await sql`
        INSERT INTO users (
          id,
          email,
          first_name,
          last_name,
          avatar_url,
          is_email_verified
        )
        VALUES (
          ${user.id},
          ${user.email},
          ${user.display_name?.split(' ')[0] || ''},
          ${user.display_name?.split(' ').slice(1).join(' ') || ''},
          ${user.profile_image_url},
          ${user.is_email_verified}
        )
        RETURNING id, email, first_name, last_name, avatar_url
      `;
      
      return {
        success: true,
        user: new_user[0],
        action: 'created'
      };
    }
  } catch (error) {
    console.error('Failed to sync Stack user:', error);
    throw new Error('Failed to sync user data');
  }
}

export async function getUserDataWithAuth(stack_token: string) {
  try {
    const validation_result = await validateStackToken(stack_token);
    
    if (!validation_result.success) {
      throw new Error('Unauthorized');
    }

    const user_data = await getUserData(validation_result.user!.id);
    return {
      success: true,
      user: user_data[0],
      stack_user: validation_result.user
    };
  } catch (error) {
    console.error('Failed to get authenticated user data:', error);
    throw new Error('Failed to get user data');
  }
}
