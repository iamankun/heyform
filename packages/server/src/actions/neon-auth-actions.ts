// Generated by An Kun
"use server";
import { neon } from "@neondatabase/serverless";
import { validateStackToken } from '../lib/stack-auth';

const sql = neon(process.env.DATABASE_URL!);

// User management actions
export async function createNeonAuthUser(user_data: {
  stack_user_id: string;
  email: string;
  display_name?: string;
  profile_image_url?: string;
  is_email_verified?: boolean;
}) {
  try {
    const data = await sql`
      INSERT INTO neon_auth.users (
        stack_user_id,
        email,
        display_name,
        profile_image_url,
        is_email_verified
      )
      VALUES (
        ${user_data.stack_user_id},
        ${user_data.email},
        ${user_data.display_name},
        ${user_data.profile_image_url},
        ${user_data.is_email_verified || false}
      )
      RETURNING id, stack_user_id, email, display_name, profile_image_url, created_at
    `;
    return data[0];
  } catch (error) {
    console.error('Failed to create neon auth user:', error);
    throw new Error('Failed to create user');
  }
}

export async function getNeonAuthUser(stack_user_id: string) {
  try {
    const data = await sql`
      SELECT 
        id,
        stack_user_id,
        email,
        display_name,
        profile_image_url,
        is_email_verified,
        created_at,
        updated_at
      FROM neon_auth.users
      WHERE stack_user_id = ${stack_user_id}
    `;
    return data[0] || null;
  } catch (error) {
    console.error('Failed to get neon auth user:', error);
    return null;
  }
}

// TODO management actions
export async function getTodosList(stack_token: string) {
  try {
    const validation_result = await validateStackToken(stack_token);
    if (!validation_result.success) {
      throw new Error('Unauthorized');
    }

    const user = await getNeonAuthUser(validation_result.user!.id);
    if (!user) {
      throw new Error('User not found');
    }

    const todos = await sql`
      SELECT 
        t.id,
        t.title,
        t.description,
        t.completed,
        t.created_at,
        t.updated_at,
        u.display_name as owner_name,
        u.email as owner_email
      FROM neon_auth.todos t
      JOIN neon_auth.users u ON t.user_id = u.id
      WHERE t.user_id = ${user.id}
      ORDER BY t.created_at DESC
    `;

    return {
      success: true,
      todos,
      user_info: {
        display_name: user.display_name,
        email: user.email
      }
    };
  } catch (error) {
    console.error('Failed to get todos list:', error);
    return {
      success: false,
      todos: [],
      error: error.message
    };
  }
}

export async function createTodo(
  stack_token: string,
  todo_data: {
    title: string;
    description?: string;
  }
) {
  try {
    const validation_result = await validateStackToken(stack_token);
    if (!validation_result.success) {
      throw new Error('Unauthorized');
    }

    let user = await getNeonAuthUser(validation_result.user!.id);
    
    // Create user if doesn't exist
    if (!user) {
      user = await createNeonAuthUser({
        stack_user_id: validation_result.user!.id,
        email: validation_result.user!.email,
        display_name: validation_result.user!.display_name,
        profile_image_url: validation_result.user!.profile_image_url,
        is_email_verified: validation_result.user!.is_email_verified
      });
    }

    const todo = await sql`
      INSERT INTO neon_auth.todos (
        title,
        description,
        user_id
      )
      VALUES (
        ${todo_data.title},
        ${todo_data.description},
        ${user.id}
      )
      RETURNING id, title, description, completed, created_at
    `;

    return {
      success: true,
      todo: todo[0]
    };
  } catch (error) {
    console.error('Failed to create todo:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

export async function updateTodoStatus(
  stack_token: string,
  todo_id: string,
  completed: boolean
) {
  try {
    const validation_result = await validateStackToken(stack_token);
    if (!validation_result.success) {
      throw new Error('Unauthorized');
    }

    const user = await getNeonAuthUser(validation_result.user!.id);
    if (!user) {
      throw new Error('User not found');
    }

    const updated_todo = await sql`
      UPDATE neon_auth.todos
      SET 
        completed = ${completed},
        updated_at = NOW()
      WHERE id = ${todo_id} AND user_id = ${user.id}
      RETURNING id, title, completed, updated_at
    `;

    return {
      success: true,
      todo: updated_todo[0]
    };
  } catch (error) {
    console.error('Failed to update todo:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

// Form ownership actions
export async function getUserForms(stack_token: string) {
  try {
    const validation_result = await validateStackToken(stack_token);
    if (!validation_result.success) {
      throw new Error('Unauthorized');
    }

    const user = await getNeonAuthUser(validation_result.user!.id);
    if (!user) {
      return { success: true, forms: [] };
    }

    const forms = await sql`
      SELECT 
        f.id,
        f.title,
        f.description,
        f.status,
        f.created_at,
        fo.role as ownership_role
      FROM forms f
      JOIN neon_auth.form_owners fo ON f.id = fo.form_id
      WHERE fo.user_id = ${user.id} AND f.deleted_at IS NULL
      ORDER BY f.created_at DESC
    `;

    return {
      success: true,
      forms
    };
  } catch (error) {
    console.error('Failed to get user forms:', error);
    return {
      success: false,
      forms: [],
      error: error.message
    };
  }
}
